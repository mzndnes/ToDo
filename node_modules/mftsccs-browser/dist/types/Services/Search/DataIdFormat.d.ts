import { Connection } from "../../app";
/**
 * ## Format DATA-ID ##
 * this function takes in connections and creates a single level objects so that all the data are added to its object/ array.
 * This is then passed on further for stiching.
 * @param connections
 * @param compositionData
 * @param reverse
 * @returns
 */
export declare function FormatFunctionDataForData(connections: Connection[], compositionData: any[], reverse?: number[]): Promise<any[]>;
/**
 * ############ Format is data-id and is used for list. ############
 * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list
 * The list format is helpful because you do not have to go over each individual query.
 * @param connections the type connections that need (external connections) to be passed
 * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}
 * @param mainComposition this is list of  ids of the main composition that builds the tree
 * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)
 * @returns
 */
export declare function FormatFromConnectionsAlteredArrayExternal(connections: Connection[], compositionData: any[], newCompositionData: any, mainComposition: number[], reverse: number[] | undefined, CountDictionary: any[]): Promise<any[]>;
/**
 * ## Format DATA-ID ##
 * this function takes in connections and creates a single level objects so that all the data are added to its object/ array.
 * This is then passed on further for stiching.
 * @param connections
 * @param compositionData
 * @param reverse
 * @returns
 */
export declare function FormatFunctionData(connections: Connection[], compositionData: any[], reverse?: number[]): Promise<any[]>;
